import logging
from abc import ABC
from functools import reduce
from typing import Callable
import pprint

import z3
import dreal
import numpy as np
import sympy as sp
import torch.nn as nn

from envs import Box, Env

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


class Verifier(ABC):
  ...


# Representation of ReLU in SymPy
ReLU = sp.Function('ReLU')


def X(dim):
  """Representation of a vector named x in SymPy."""
  return sp.Matrix(
    [sp.Symbol(f'x_{i}') for i in range(dim)] )


def Net(net: nn.Sequential, x: sp.Matrix):
  """Representation of a ReLU-activated NN in SymPy.
  
  Args:
    net: an instance of nn.Sequential. We assume all layers are 
    instances of either nn.Linear (fully connected feed-forward) or 
    nn.ReLU (activation functions).
  """
  for layer in net:
    if isinstance(layer, nn.Linear):
      W = layer.weight.data.numpy()
      # If the layer has no bias, we simply set bias to 0.
      # Expand_dims changes a 1D vector into a 2D column vector.
      b = (
        layer.bias.data.numpy() 
        if layer.bias is not None 
        else np.zeros(len(W)) )
      b = np.expand_dims(b, 1) 
      x = W @ x + b
    if isinstance(layer, nn.ReLU):
      x = x.applyfunc(ReLU)
  return x 


def BoundIn(box: Box, x):
  B = []
  dim = len(box.low)
  low = box.low.numpy()
  high = box.high.numpy()
  B += [x[i] >= low [i] for i in range(dim)]
  B += [x[i] <= high[i] for i in range(dim)]
  return reduce(lambda a, b: a & b, B)


def BoundOut(box: Box, x):
  B = []
  dim = len(box.low)
  low = box.low.numpy()
  high = box.high.numpy()
  B += [x[i] < low [i] for i in range(dim)]
  B += [x[i] > high[i] for i in range(dim)]
  return reduce(lambda a, b: a | b, B)


def Norm_L1(x):
  acc = sp.Abs(x[0])
  for i in range(1, len(x)):
    acc += sp.Abs(x[i])
  return acc


def solve_z3(C, x):
  """Satisfying model for C, generated by Z3.
  If a model exists for C, this function returns a list 
  [y_1, ..., y_k], where y_i = model[x_i].
  
  Assumption. All variables in x are Real.
  
  Args:
    C: A list of Z3 constraints.
    x: A list of Z3 variables.
  """
  s = z3.Solver()
  s.add(C)
  chk = s.check()
  if chk == z3.sat:
    m = s.model()
    n = len(x)
    return [ float(m[x[i]].as_fraction()) for i in range(n) ]
  elif chk == z3.unsat:
    return None
  else:
    raise RuntimeError('unknown result for SMT query')


def solve_dreal(F, x, delta=1e-3):
  """Satisfying model for C, generated by DReal."""
  result = dreal.CheckSatisfiability(F, delta) 
  if not result:
    return None 
  return [result[x[i]].mid() for i in range(len(x))]


def sympy_to_z3(expr, var):
  """Translate SymPy expression to Z3.

  Args:
    expr: SymPy expression.
    var: a dictionary mapping SymPy Symbols to their Z3 equivalents. 
  """
  if isinstance(expr, sp.Symbol):
    return var[expr]
  if isinstance(expr, sp.Number):
    return expr
  if isinstance(expr, sp.Add):
    acc = sympy_to_z3(expr.args[0], var)
    for arg in expr.args[1:]:
      acc += sympy_to_z3(arg, var)
    return acc
  if isinstance(expr, sp.Mul):
    acc = sympy_to_z3(expr.args[0], var)
    for arg in expr.args[1:]:
      acc *= sympy_to_z3(arg, var)
    return acc
  if isinstance(expr, sp.And):
    args = [sympy_to_z3(arg, var) for arg in expr.args]
    return z3.And(args)
  if isinstance(expr, sp.Or):
    args = [sympy_to_z3(arg, var) for arg in expr.args]
    return z3.Or(args)
  if isinstance(expr, sp.Function) and expr.name == 'ReLU':
    arg = sympy_to_z3(expr.args[0], var)
    return z3.If(arg < 0, 0, arg)
  if isinstance(expr, sp.GreaterThan):
    l, r = [sympy_to_z3(arg, var) for arg in expr.args]
    return l >= r
  if isinstance(expr, sp.LessThan):
    l, r = [sympy_to_z3(arg, var) for arg in expr.args]
    return l <= r
  if isinstance(expr, sp.StrictGreaterThan):
    l, r = [sympy_to_z3(arg, var) for arg in expr.args]
    return l > r
  if isinstance(expr, sp.StrictLessThan):
    l, r = [sympy_to_z3(arg, var) for arg in expr.args]
    return l < r
  raise NotImplementedError(type(expr))


def sympy_to_dreal(expr, var):
  """Translate SymPy expression to DReal.

  Args:
    expr: SymPy expression.
    var: a dictionary mapping SymPy Symbols to their DReal ebquivalents. 
  """
  if isinstance(expr, sp.Symbol):
    return var[expr]
  if isinstance(expr, sp.Number):
    return expr
  if isinstance(expr, sp.Add):
    acc = sympy_to_dreal(expr.args[0], var)
    for arg in expr.args[1:]:
      acc += sympy_to_dreal(arg, var)
    return acc
  if isinstance(expr, sp.Mul):
    acc = sympy_to_dreal(expr.args[0], var)
    for arg in expr.args[1:]:
      acc *= sympy_to_dreal(arg, var)
    return acc
  if isinstance(expr, sp.And):
    args = [sympy_to_dreal(arg, var) for arg in expr.args]
    return dreal.And(*args)
  if isinstance(expr, sp.Or):
    args = [sympy_to_dreal(arg, var) for arg in expr.args]
    return dreal.Or(*args)
  if isinstance(expr, sp.GreaterThan):
    l, r = [sympy_to_dreal(arg, var) for arg in expr.args]
    return l >= r
  if isinstance(expr, sp.LessThan):
    l, r = [sympy_to_dreal(arg, var) for arg in expr.args]
    return l <= r
  if isinstance(expr, sp.StrictGreaterThan):
    l, r = [sympy_to_dreal(arg, var) for arg in expr.args]
    return l > r
  if isinstance(expr, sp.StrictLessThan):
    l, r = [sympy_to_dreal(arg, var) for arg in expr.args]
    return l < r
  # Functions 
  if isinstance(expr, sp.Abs):
    arg = sympy_to_dreal(expr.args[0], var)
    return dreal.if_then_else(arg > 0, arg, 0)
  if isinstance(expr, sp.sin):
      arg = sympy_to_dreal(expr.args[0], var)
      return dreal.sin(arg)
  if isinstance(expr, sp.cos):
    arg = sympy_to_dreal(expr.args[0], var)
    return dreal.cos(arg)
  if isinstance(expr, sp.exp):
    arg = sympy_to_dreal(expr.arg[0], var)
    return dreal.exp(arg)
  if isinstance(expr, sp.Function) and expr.name == 'ReLU':
    arg = sympy_to_dreal(expr.args[0], var)
    return dreal.if_then_else(arg < 0, 0, arg)
  raise NotImplementedError(type(expr))


# Verifiers are named after their corresponding learners. Concretely, 
# Verifier_W (where W is a string) corresponds to Learner_W.

class Verifier_Reach_C(Verifier):
  def __init__(
      self,
      cert: nn.Sequential,
      env: Env,
      F: Callable):
    self.cert = cert
    self.env = env
    self.F = F
  
  def chk_dec(self):
    x_sp = X(self.env.dim)
    x_z3 = z3.RealVector('x', self.env.dim)
    var = {x_sp[i]: x_z3[i] for i in range(self.env.dim)}
    v, vf = z3.Real('v'), z3.Real('vf')

    # The lists bound and problem contain SymPy expressions for 
    # variable bounds and problem constrains.
    bounds, problem = [], []
    bounds.append(BoundIn(self.env.bnd, x_sp))
    bounds.append(BoundOut(self.env.tgt, x_sp))
    bounds = [sympy_to_z3(b, var) for b in bounds]
    problem.append(
      v  == sympy_to_z3( Net(self.cert, x_sp)[0], var) )
    problem.append(
      vf == sympy_to_z3( Net(self.cert, self.F(x_sp))[0], var) )
    problem.append(v <= vf)
    logger.debug('bounds='  + pprint.pformat(bounds))
    logger.debug('problem=' + pprint.pformat(problem))
    return solve_z3(bounds + problem, x_z3)


class Verifier_Reach_ABV(Verifier):
  def __init__(
      self,
      A: nn.Sequential,
      B: nn.Sequential,
      V: nn.Sequential,
      env: Env,
      F: Callable):
    self.A = A
    self.B = B
    self.V = V
    self.env = env
    self.F = F

  def chk_abst(self):
    x_sp = X(self.env.dim)
    x_dr = [dreal.Variable(f'x_{i}') for i in range(self.env.dim)]
    var = {x_sp[i]: x_dr[i] for i in range(self.env.dim)}
    
    err = Net(self.A, x_sp) - self.F(x_sp)
    err = Norm_L1(err)
    b = Net(self.B, x_sp)
    assert b.shape == (1, 1)
    b = b[0]
    bounds = sympy_to_dreal(BoundIn(self.env.bnd, x_sp), var)
    problem = sympy_to_dreal(err > b, var)
    return solve_dreal(dreal.And(bounds, problem), x_dr)
